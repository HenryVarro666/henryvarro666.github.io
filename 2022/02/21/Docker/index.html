<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"henryvarro666.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="Docker Tutorial https:&#x2F;&#x2F;www.docker.com&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="https://henryvarro666.github.io/2022/02/21/Docker/index.html">
<meta property="og:site_name" content="我见青山多妩媚，料青山 见我应如是">
<meta property="og:description" content="Docker Tutorial https:&#x2F;&#x2F;www.docker.com&#x2F;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202240942238.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202240942337.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202241004615.svg%252Bxml">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202241004368.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202240916374.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202241112816.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202241139888.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202270838438.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202270952025.png">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202271016159.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202271110444.png">
<meta property="article:published_time" content="2022-02-21T21:22:58.000Z">
<meta property="article:modified_time" content="2022-03-01T03:58:02.069Z">
<meta property="article:author" content="Chao Cao">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202240942238.png">

<link rel="canonical" href="https://henryvarro666.github.io/2022/02/21/Docker/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Docker | 我见青山多妩媚，料青山 见我应如是</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">我见青山多妩媚，料青山 见我应如是</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Chao の Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://henryvarro666.github.io/2022/02/21/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Chao Cao">
      <meta itemprop="description" content="为天地立心，为生民立命，为往圣继绝学，为万世开太平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我见青山多妩媚，料青山 见我应如是">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Docker
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-21 16:22:58" itemprop="dateCreated datePublished" datetime="2022-02-21T16:22:58-05:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-28 22:58:02" itemprop="dateModified" datetime="2022-02-28T22:58:02-05:00">2022-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A7%91%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">科研</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>26 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Docker Tutorial</p>
<p><a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a></p>
<span id="more"></span>

<h1 id="大佬slides的结构"><a href="#大佬slides的结构" class="headerlink" title="大佬slides的结构"></a>大佬slides的结构</h1><ol>
<li><p>Docker的定义</p>
</li>
<li><p>Docker架构</p>
<p>*：不同系统下的架构</p>
</li>
<li><p>Docker优势</p>
</li>
<li><p>Docker三个基本概念</p>
<ul>
<li>Image</li>
<li>Container</li>
<li>Repository</li>
</ul>
</li>
<li><p>Docker常用command</p>
</li>
<li><p>Dockerfile</p>
<p>构建镜像</p>
<p>使用的命令行&#x2F;参数</p>
<p>*：layered architecture</p>
<p>构建成功之后的代码运行界面</p>
</li>
<li><p>Docker文件系统</p>
<ol>
<li>AUFS&#x2F;创建容器时AUFS产生的变化</li>
<li>Volumes</li>
<li>Bind mounts</li>
</ol>
</li>
<li><p>Docker容器连接</p>
</li>
<li><p>Docker容器互联</p>
<p>*：网络结构图</p>
</li>
<li><p>Docker Compose</p>
</li>
<li><p>Docker仓库管理</p>
</li>
<li><p>References</p>
</li>
</ol>
<h2 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h2><div class="pdfobject-container" data-target="./DockerSlides.pdf" data-height="500px"></div>



<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a target="_blank" rel="noopener" href="https://docs.docker.com/desktop/mac/install/">Install Docker Desktop on Mac</a></p>
<p>（However, to get the best experience, we recommend that you install Rosetta 2）</p>
<h3 id="自带的tutorial命令行"><a href="#自带的tutorial命令行" class="headerlink" title="自带的tutorial命令行"></a>自带的tutorial命令行</h3><p><code>docker run -d -p 80:80 docker/getting-started</code></p>
<p>![Screen Shot 2022-02-21 at 16.38.18](<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/HenryVarro666/images/master/uPic/Screen">https://raw.githubusercontent.com/HenryVarro666/images/master/uPic/Screen</a> Shot 2022-02-21 at 16.38.18.png)</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Docker">https://zh.wikipedia.org/wiki/Docker</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/">https://yeasy.gitbook.io/docker_practice/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv15180540">https://www.bilibili.com/read/cv15180540</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv15181760">https://www.bilibili.com/read/cv15181760</a></p>
</li>
</ol>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=iqqDU2crIEQ">https://www.youtube.com/watch?v=iqqDU2crIEQ</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=pTFZFxd4hOI">https://www.youtube.com/watch?v=pTFZFxd4hOI</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=3c-iBn73dDE">https://www.youtube.com/watch?v=3c-iBn73dDE</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=fqMOX6JJhGo">https://www.youtube.com/watch?v=fqMOX6JJhGo</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1s54y1n7Ev?from=search&amp;seid=6545698363302615398&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1s54y1n7Ev?from=search&amp;seid=6545698363302615398&amp;spm_id_from=333.337.0.0</a></li>
</ol>
<h1 id="Slides结构"><a href="#Slides结构" class="headerlink" title="Slides结构"></a>Slides结构</h1><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a></p>
<h2 id="What-can-I-use-Docker-for"><a href="#What-can-I-use-Docker-for" class="headerlink" title="What can I use Docker for?"></a>What can I use Docker for?</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a></p>
<h2 id="和传统的虚拟化方式比较"><a href="#和传统的虚拟化方式比较" class="headerlink" title="和传统的虚拟化方式比较"></a>和传统的虚拟化方式比较</h2><ul>
<li><p>Linux容器基础之LXC技术介绍：</p>
<p>描述:Docker引擎的基础是Linux容器(Linux Containers,LXC)技术,容器有效的将各个操作系统管理的资源划分到孤立的组,以便更好的在孤立的组之间平衡有冲突的资源使用需求。<br>容器可以在核心CPU本地运行指令,并不需要任何专门的解释机制;最早的容器技术可以追溯到1982年Unix系列操作系统上的chroot工具;用户操作容器就像操作一个轻量级虚拟机那样简单,也可以将容器比作为一种沙盒(Sandbox) </p>
<p>传统虚拟化</p>
<p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202240942238.png" alt="传统虚拟化"></p>
<p>Docker</p>
<p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202240942337.png" alt="Docker"></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv15180540">https://www.bilibili.com/read/cv15180540</a></p>
<p><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/introduction/why">https://yeasy.gitbook.io/docker_practice/introduction/why</a></p>
<p>传统虚拟化方式是在硬件层面实现虚拟化,需要有额外的虚拟机管理应用和虚拟机操作系统层，然后在该系统上运行业务所需程序;</p>
<p>Docker虚拟化方式是在宿主系统层面上实现虚拟化,直接复用本地主机的操作系统与内核，容器内没有自己的内核，所以容器内的应用进程实际运行于宿主机内核,因此更加轻量级</p>
<ul>
<li><p>什么是虚拟化技术?<br>虚拟化技术是一个通用的概念,在不同的领域有不同的理解;在计算机领域一般指的是计算机虚拟化(Computer Virtualization)或者说是服务器虚拟化;虚拟化的核心是对资源进行抽象和管理,目标往往是为了在同一个主机上运行多个系统或者应用,从而提高系统资源的利用率,同时带来降低成本,方便管理和容错和容灾等好处;</p>
<ul>
<li><p>硬件虚拟化:真正意义上的基于它的技术不多见,少数网卡中的单根多IO虚拟化等技术;</p>
</li>
<li><p>软件虚拟化(Virtualization)</p>
</li>
</ul>
<p>1.应用虚拟化</p>
<p>2.平台虚拟化:细分</p>
<p>2.1 完全虚拟化</p>
<p>2.2 硬件辅助虚拟化:利用硬件CPU辅助支持虚拟化技术Intel-VT和AND-V处理铭感指令来实现完全虚拟化的功能;</p>
<p>2.3 部分虚拟化:只对部分硬件资源进行虚拟化,客户端系统需要进行修改;</p>
<p>2.4 准虚拟化(Paravirtualization):如xen</p>
<p>2.5 操作系统级虚拟化:内核通过创建多个虚拟化的操作系统实例内核和库来隔离不同的进程,dokcer以及其他容器都在这个范畴之内; 作者：WeiyiGeek <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv15180540">https://www.bilibili.com/read/cv15180540</a> 出处：bilibili</p>
</li>
</ul>
<h2 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h2><h2 id="Docker的体系（architecture）"><a href="#Docker的体系（architecture）" class="headerlink" title="Docker的体系（architecture）"></a>Docker的体系（architecture）</h2><p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202241004615.svg%252Bxml" alt="Docker Architecture Diagram"></p>
<p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202241004368.png" alt="image-20220224100436306"></p>
<h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a><strong>daemon</strong></h3><p>A background process that handles requests for services such as print spooling and file transfers, and is dormant when not required.</p>
<p>(指在某种条件得到满足时能自动进行工作的计算机程序)，守护程序</p>
<p>监听 Docker API 请求并管理 Docker 对象，如图像、容器、网络和卷。守护进程还可以与其他守护进程通信，以管理 Docker 服务。</p>
<h2 id="完整的Docker组成"><a href="#完整的Docker组成" class="headerlink" title="完整的Docker组成"></a>完整的Docker组成</h2><p>(1) 守护进程(Daemon)：Docker守护进程(dockerd)侦听Docker API请求并管理Docker对象,，如图像、容器、网络和卷。守护进程还可以与其他守护进程通信来管理Docker服务。</p>
<p>(2) REST API: 主要与Docker Daemon进行交互，比如Docker Cli或者直接调用REST API；</p>
<p>(3) 客户端(Docker Client): 它是与Docker交互的主要方式通过命令行接口(CLI)客户端(docker命令)，客户机将命令通过REST API发送给并执行其命令；()</p>
<p>(4) Register Repository 镜像仓库: Docker注册表存储Docker镜像，可以采用Docker Hub是公共注册仓库，或者采用企业内部自建的Harbor私有仓库;</p>
<p>(5) Image 镜像: 映像是一个只读模板，带有创建Docker容器的指令。映像通常基于另一个映像，还需要进行一些额外的定制，你可以通过Docker Hub公共镜像仓库进行拉取对应的系统或者应用镜像;</p>
<p>(6) Container 容器: 容器是映像的可运行实例。您可以使用Docker API或CLI创建、启动、停止、移动或删除容器。您可以将一个容器连接到一个或多个网络，将存储附加到它，甚至根据它的当前状态创建一个新映像。</p>
<p>(7) Services : Docker引擎支持集群模式服务允许您跨多个Docker守护进程()扩展管理容器，服务允许您定义所需的状态，例如在任何给定时间必须可用的服务副本的数量。默认情况下，服务在所有工作节点之间进行负载平衡。对于使用者来说Docker服务看起来是一个单独的应用程序</p>
<p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202240916374.webp" alt="WeiyiGeek.引擎图"></p>
<h2 id="Docker内部的具体实现"><a href="#Docker内部的具体实现" class="headerlink" title="Docker内部的具体实现"></a>Docker内部的具体实现</h2><p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202241112816.webp" alt="Docker 内部具体实现"></p>
<h2 id="Docker资源隔离"><a href="#Docker资源隔离" class="headerlink" title="Docker资源隔离"></a>Docker资源隔离</h2><p>Docker 本质是宿主机上的一个进程</p>
<p>•通过namespace实现资源隔离以及轻量级虚拟化容器服务</p>
<p>•通过cgroup实现了资源限制</p>
<p>•通过写时复制技术(Copy-on-write)实现了高效的文件操作</p>
<p>Docker通过由内核namespace提供实现的隔离，namespace的API包括还有在&#x2F;proc下的部分文件</p>
<p>•进程隔离：每个容器都运行在自己的进程环境中</p>
<p>•网络隔离：容器间的虚拟网络接口和 IP 地址都是分开的</p>
<p>•文件系统隔离：每个容器都有自己的 root 文件系统</p>
<p>•资源隔离和分组：使用 cgroups 将 CPU 和内存之类的资源独立分配给每个 Docker 容器</p>
<h3 id="Namespace的六项隔离"><a href="#Namespace的六项隔离" class="headerlink" title="Namespace的六项隔离"></a>Namespace的六项隔离</h3><p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202241139888.webp" alt="namespace的六项隔离"></p>
<h2 id="Docker常见概念"><a href="#Docker常见概念" class="headerlink" title="Docker常见概念"></a>Docker常见概念</h2><table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Docker 镜像(Images)</td>
<td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td align="left">Docker 容器(Container)</td>
<td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td align="left">Docker 客户端(Client)</td>
<td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a target="_blank" rel="noopener" href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="left">Docker 主机(Host)</td>
<td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="left">Docker Registry</td>
<td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td>
</tr>
<tr>
<td align="left">Docker Machine</td>
<td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure</td>
</tr>
</tbody></table>
<h1 id="指令-重要概念"><a href="#指令-重要概念" class="headerlink" title="指令+重要概念"></a>指令+重要概念</h1><h2 id="image-镜像"><a href="#image-镜像" class="headerlink" title="image 镜像"></a>image 镜像</h2><p>images 类似于虚拟机镜像，借鉴了Git利用分成分层优点，通过文件系统分层的概念实现了分层复用，极大的节约了磁盘空间；</p>
<p>简单的您可以将它理解成为<u><strong>一个面向Docker引擎的只读模板包含文件系统</strong></u> </p>
<h3 id="创建镜像的方法"><a href="#创建镜像的方法" class="headerlink" title="创建镜像的方法"></a>创建镜像的方法</h3><ol>
<li>从已有镜像的容器创建</li>
<li>基于本地模板导入：使用操作系统模板导入一个镜像文件</li>
<li>基于Dockerfile导入</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######### 从已有镜像创建 ############</span></span><br><span class="line">$sudo docker commit [option-选项] ContainerId [Repository[:Tag]]</span><br><span class="line">$sudo docker commit -m <span class="string">&quot;xx&quot;</span> -a <span class="string">&quot;oo&quot;</span> ContainerID(被修改过的ID) [Repository[:Tag]]</span><br><span class="line"></span><br><span class="line">-a,--author=<span class="string">&quot;作者&quot;</span></span><br><span class="line"></span><br><span class="line">-m,--message=<span class="string">&quot;更改信息&quot;</span></span><br><span class="line"></span><br><span class="line">-p,--pause=ture 提交时暂停容器Container运行</span><br><span class="line"></span><br><span class="line">$sudo docker run -it centos:latest /<span class="built_in">bin</span>/bash</span><br><span class="line">[root@32a481e170c6 ~]$ touch &#123;<span class="number">1.</span><span class="number">.10</span>&#125;.txt  <span class="comment">#上面这个容器ID非常重要在进行修改之后</span></span><br><span class="line"></span><br><span class="line">$sudo docker container ls -a   <span class="comment">#查看容器记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个新的镜像</span></span><br><span class="line">$sudo docker commit -m <span class="string">&quot;Zabbix base in Centos7&quot;</span> -a <span class="string">&quot;Weiyigeek&quot;</span> 32a481e170c6 centoszabbix:latest</span><br><span class="line">sha256:680ddb57c4b80c625ef68e113f553ee932a06f25d4685d25a0b6464cf5d60982  <span class="comment">#成功会给出一个镜像ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######### 从本地模板导入 ############</span></span><br><span class="line">$sudo cat ubuntu-<span class="number">14.04</span>.tar.gz | docker <span class="keyword">import</span> - ubuntu:<span class="number">14.04</span>  <span class="comment">#本地导入镜像命令 </span></span><br></pre></td></tr></table></figure>

<p>当该镜像在容器运行存在的时候,镜像文件默认是无法被删除的;必须停止&#x2F;删除容器ID才能删除镜像文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当同一个镜像有多个标签的时候rmi命令只是删错了该进行的标签而且,并不影响镜像文件</span></span><br><span class="line"><span class="comment">#但当只剩下一个标签的时候就要小心了,如果在停止的状态下再次使用rmi命令则会删除该镜像</span></span><br><span class="line">$ sudo docker rmi ubuntu18<span class="number">.04</span></span><br><span class="line">Untagged: ubuntu18<span class="number">.04</span>:latest</span><br><span class="line">$ sudo docker rmi ubuntu ubuntutls</span><br><span class="line">Untagged: ubuntu:latest</span><br><span class="line">Untagged:  <span class="comment">#删除了这个镜像文件的所有AUFS层</span></span><br><span class="line">ubuntu@sha256:d26d529daa4d8567167181d9d569f2a85da3c5ecaf539cace2c6223355d69981</span><br><span class="line"></span><br><span class="line">$ sudo docker rmi -f ubuntutls  <span class="comment">#强制删除</span></span><br><span class="line">Untagged: ubuntutls:latest</span><br><span class="line">Deleted: sha256:d131e0fa2585a7efbfb187f70d648aa50e251d9d3b7031edf4730ca6154e221e</span><br></pre></td></tr></table></figure>



<h3 id="镜像操作常用命令"><a href="#镜像操作常用命令" class="headerlink" title="镜像操作常用命令"></a>镜像操作常用命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#搜索关于Archlinux镜像,输出信息不截断显示</span></span><br><span class="line">docker search --no-trunc=false [镜像名称] </span><br><span class="line"></span><br><span class="line"><span class="comment">#仓库名(Repository) 或者 标签名[不指定着默认latest,即最新]</span></span><br><span class="line"><span class="comment">#获取Hub镜像如果不指定TAG将默认选择仓库中最新颁布的镜像</span></span><br><span class="line">docker pull name/[repository[:tag]] </span><br><span class="line"></span><br><span class="line"><span class="comment">#上传到docker仓库</span></span><br><span class="line">docker push DockerHubUser用户/test:latest  </span><br><span class="line"></span><br><span class="line"><span class="comment">#列出本机已有镜像</span></span><br><span class="line">docker images   </span><br><span class="line"></span><br><span class="line"><span class="comment">#为本地镜像添加一个新标签 [注意仓库名称必须小写]</span></span><br><span class="line">docker tag 原仓库[:标签] 新仓库名[:标签]  </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改镜像的标签</span></span><br><span class="line">docker tag &lt;image <span class="built_in">id</span>&gt; username/name:devel</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取镜像的详细信息</span></span><br><span class="line">docker inspect [image <span class="built_in">id</span>]  </span><br><span class="line"></span><br><span class="line"><span class="comment">#-f 获取单个属性 返回JSON</span></span><br><span class="line">docker inspect -f &#123;&#123;<span class="string">&quot;.Architecture&quot;</span>&#125;&#125; <span class="number">550</span>(images Id 前面<span class="number">3</span>位) </span><br><span class="line"></span><br><span class="line"><span class="comment">#删除镜像 镜像id|仓库名称</span></span><br><span class="line">docker rmi [&lt;image <span class="built_in">id</span>&gt;|&lt;repository&gt; ]   </span><br><span class="line"></span><br><span class="line"><span class="comment">#不建议强行删除正在容器中运行的镜像文件</span></span><br><span class="line">docker rmi -f &lt;images <span class="built_in">id</span>&gt;   </span><br><span class="line"></span><br><span class="line"><span class="comment">#将镜像文件打包存出到磁盘</span></span><br><span class="line">docker save -o 保存文件名.tar  [repository[:tag]]  </span><br><span class="line"></span><br><span class="line"><span class="comment">#将镜像文件打包存出到磁盘</span></span><br><span class="line">docker save [repository[:tag]] &gt; 保存文件名 </span><br><span class="line"></span><br><span class="line"><span class="comment">#将打包的镜像文件进行载入</span></span><br><span class="line">docker load --<span class="built_in">input</span> 保存文件名.tar  </span><br><span class="line">docker load &lt; 保存文件名.tar </span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202270838438.png" alt="image-20220227083846357"></p>
<h3 id="save和export的区别"><a href="#save和export的区别" class="headerlink" title="save和export的区别"></a>save和export的区别</h3><ol>
<li><p>save 与 load 命令对应即导出与导入镜像，而export与import命令对应即导出导入容器;</p>
</li>
<li><p>save 保存后 load 加载的镜像没有丢失历史和层(Layer),而容器export导出然后import导入时所有的提交历史将会丢失，这意味着您无法回滚到之前的层;</p>
</li>
<li><p>补充:通过import导入的方式镜像只有一层，而通过commit的方式生成的镜像实际是在原有的Base Image(即复写层)上又生成了一层</p>
</li>
</ol>
<h2 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container 容器"></a>Container 容器</h2><p>镜像自身只读的,容器从镜像启动的时候会在镜像的最上层创建一个可写层,镜像本身将保持不变 </p>
<h3 id="创建并运行容器的标准操作"><a href="#创建并运行容器的标准操作" class="headerlink" title="创建并运行容器的标准操作"></a>创建并运行容器的标准操作</h3><ul>
<li>检查本地是否存在指定镜像,不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统,并在只读的镜像层外面挂载一个可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个IP地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="启动容器有两种方式"><a href="#启动容器有两种方式" class="headerlink" title="启动容器有两种方式"></a>启动容器有两种方式</h3><ul>
<li>一种是基于镜像新建一个容器并启动</li>
<li>另外一个是将在终止状态（stopped）的容器重新启动</li>
</ul>
<h3 id="容器操作常用命令"><a href="#容器操作常用命令" class="headerlink" title="容器操作常用命令"></a>容器操作常用命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建容器但处于停止状态</span></span><br><span class="line">docker create -it repository[:tag]</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动创建的容器</span></span><br><span class="line">docker start -a -i &lt;container <span class="built_in">id</span>&gt;   </span><br><span class="line"></span><br><span class="line"><span class="comment">#-a 参数   连接容器并打印输出或错误 -</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-i 参数   启动容器并进入交互模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建并启动容器 等同于上面两条命令</span></span><br><span class="line">docker run -t -i repository[:tag]  /<span class="built_in">bin</span>/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#-t:让Docker分配一个伪终端(pseudo-tty)并绑定在容器的标准输入上.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-i:则让容器的标准输入保持打开.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CTRL+Z 和 Exit 则退出容器Container</span></span><br><span class="line"></span><br><span class="line">docker run -d repository[:tag] /<span class="built_in">bin</span>/sh -C <span class="string">&quot;echo hello word&quot;</span> <span class="comment">#守护态运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-d 参数即可后台运行,用户无法看到容器中的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-c 执行的Command</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#--rm 添加这个标记,容器会在停止后立即删除自身   (注意：与-d不能同时使用)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#--name 使用--name web 标记可以为容器重新命名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取容器的输出信息</span></span><br><span class="line">docker logs &lt;Container-<span class="built_in">id</span>&gt;      </span><br><span class="line"></span><br><span class="line"><span class="comment">#采用ps -a NAMES 进入容器</span></span><br><span class="line">docker attach [names]  </span><br><span class="line"></span><br><span class="line"><span class="comment">#docker exec 至1.3版本起可以在容器中运行命令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;Container-<span class="built_in">id</span>&gt;  /<span class="built_in">bin</span>/bash  </span><br><span class="line"></span><br><span class="line"><span class="comment">#显示本机上的所有容器ID运行的容器ID信息</span></span><br><span class="line">docker ps -aq   </span><br><span class="line"></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line">docker restart &lt;container <span class="built_in">id</span>&gt;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">#停止容器</span></span><br><span class="line">docker stop &lt;container <span class="built_in">id</span>&gt; </span><br><span class="line"><span class="comment">#强行终止容器 可以直接发送SIGKILL信号来终止容器</span></span><br><span class="line">docker kill &lt;cantainer <span class="built_in">id</span>&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment">#删除容器删除依赖该镜像的容器ID,前3位即可</span></span><br><span class="line">docker rm &lt;container <span class="built_in">id</span>&gt;    </span><br><span class="line"></span><br><span class="line"><span class="comment">#-f,--force=false 强制终止并删除一个运行中的容器[默认会发生SIGKILL信号]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-l,--link=false  删除容器连接但保留容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-v,--volumes=false  删除容器挂载的数据卷</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#导出容器</span></span><br><span class="line">docker export &lt;container <span class="built_in">id</span>&gt; &gt;导出文件.tar  </span><br><span class="line"></span><br><span class="line"><span class="comment">#导入容器 </span></span><br><span class="line">docker <span class="keyword">import</span> - repository[:tag] </span><br></pre></td></tr></table></figure>

<h3 id="Docker-load-与-Docker-import-的比较"><a href="#Docker-load-与-Docker-import-的比较" class="headerlink" title="Docker load 与 Docker import 的比较"></a>Docker load 与 Docker import 的比较</h3><p>描述：导入容器和导入镜像是差不多的但是实际上又是有所区别的</p>
<p>load：导入镜像存储文件到本地镜像库 </p>
<p> import：导入一个容器快照到本地镜像库</p>
<p>容器快照：文件将丢失所有的历史记录和元数据信息(即保留容器当时的快照状态),导入的时候还需要重新制定标签等元数据信息;</p>
<p>镜像存储：文件将保存完整的记录,并且体积也要大</p>
<h3 id="rm和rmi的区别"><a href="#rm和rmi的区别" class="headerlink" title="rm和rmi的区别"></a>rm和rmi的区别</h3><ul>
<li>docker rm ： 删除一个或多个 容器</li>
<li>docker rmi ： 删除一个或多个 镜像 </li>
<li>docker prune ： 用来删除不再使用的 docker 对象</li>
</ul>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>一个 <strong>Docker Registry</strong> 中可以包含多个 仓库（<strong>Repository</strong>）；每个仓库可以包含多个 标签（<strong>Tag</strong>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <u>&lt;仓库名&gt;:&lt;标签&gt;</u> 的格式来指定具体是这个软件哪个版本的镜像。</p>
<p>如果不给出标签，将以 latest 作为默认标签。</p>
<p>分为公开（Public）和私有(Private)。前者有多个版本，后者为用户自己搭建</p>
<h3 id="Public"><a href="#Public" class="headerlink" title="Public"></a>Public</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的 官方镜像。</p>
<p>除此以外，还有 Red Hat 的 Quay.io；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务；代码托管平台 GitHub 推出的 ghcr.io。</p>
<h4 id="Private"><a href="#Private" class="headerlink" title="Private"></a>Private</h4><p>Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p>
<p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p>
<h3 id="镜像仓库操作常用命令"><a href="#镜像仓库操作常用命令" class="headerlink" title="镜像仓库操作常用命令"></a>镜像仓库操作常用命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#连接并初始化hub仓库 需要输入用户名和密码认证,然后存放于/root/.docker/config.json 文件中</span></span><br><span class="line">docker login   </span><br><span class="line"></span><br><span class="line"><span class="comment">#下载指定仓库到本地</span></span><br><span class="line">docker pull [repository] </span><br><span class="line"></span><br><span class="line"><span class="comment">#上传镜像到仓库</span></span><br><span class="line">docker push [imges]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建和使用私有仓库"><a href="#创建和使用私有仓库" class="headerlink" title="创建和使用私有仓库"></a>创建和使用私有仓库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> registry</span><br><span class="line"><span class="comment">#默认情况下仓库创建在容器的/tmp/register目录下,-v 通过镜像文件存放在宿主机本地的指定路径/opt/data/registry上;</span></span><br><span class="line">$ docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> -v /opt/data/registry:/tmp/registry registry</span><br><span class="line"></span><br><span class="line"><span class="comment">#-d:容器启动后会进入后台,用户无法看到容器中的信息.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-p:指定仓库镜像的端口.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-v:将镜像的存放位置放在本地指定的路径上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#此时会在本地启动一个私有仓库服务,监听端口为5000; 更新标签本地仓库地址并上传到私有仓库之中 </span></span><br><span class="line"><span class="comment">#更改镜像的标签 </span></span><br><span class="line">$docker tag ubuntu:<span class="number">14.04</span> <span class="number">10.0</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">5000</span>/test  </span><br><span class="line"></span><br><span class="line"><span class="comment">#下载镜像</span></span><br><span class="line">$docker pull <span class="number">10.0</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">5000</span>/test              </span><br><span class="line"> </span><br><span class="line"><span class="comment">#可以以这个来测试是不是存在docker 5000未授权访问漏洞</span></span><br><span class="line"><span class="comment">#上传成功后可以查看到返回的json字符串 </span></span><br><span class="line">$ curl http://<span class="number">10.0</span><span class="number">.2</span><span class="number">.2</span>:<span class="number">5000</span>/v1/search  </span><br></pre></td></tr></table></figure>

<h3 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h3><p>curl是一个开源的用于数据传输的命令行工具与库，它使用URL语法格式，支持众多传输协议。作用是发出网络请求，然后获取数据，显示在”标准输出”（stdout）上面。</p>
<h3 id="自动创建（Automated-Builds）"><a href="#自动创建（Automated-Builds）" class="headerlink" title="自动创建（Automated Builds）"></a>自动创建（Automated Builds）</h3><p>对于需要经常升级镜像内程序来说十分的方便 </p>
<ul>
<li>创建登录Docker Hub 绑定Github;</li>
<li>在Docker Hub中配置一个自动创建</li>
<li>选取一个目标网站中的项目(需要Dockerfile和分支)</li>
<li>指定Dockerfile的位置并提交创建,可以在”自动创建页面”跟踪每次创建的状态;</li>
</ul>
<p>总结：仓库管理镜像的设计理论与Git差不多,工作流程为文件分发和合作带来的众多优势</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile是一个文本格式的配置文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,因此每一条指令的内容,就是描述该层应当如何构建。<br>用户可以使用Dockerfile快速创建自定义的镜像;通过它所支持的内部指令,以及使用它创建镜像的基本过程,Docker拥有”一点修改代替大量更新”的灵活之处</p>
<ul>
<li><p>文本化的镜像生成操作让其方便版本管理和自动化部署</p>
<p>方便部署</p>
</li>
<li><p>每条命令对应镜像的一层,细化操作后保证其可增量更新,复用镜像块减小镜像体积 </p>
<p>减小体积</p>
</li>
</ul>
<p>总结为一点就是**<u>将每一层修改、安装、构建、操作命令都写入到一个脚本之中</u>**。</p>
<p>[一个镜像构建时不能超过 127 层，我们需要保证了稳定的变化的命令至于上层保证了每层打包出来的 Layer 能够尽可能的复用,而不会徒增镜像的大小，影响后续拉取镜像的速度 ]</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>•基础镜像信息：FROM &lt;image&gt; 或者 FROM &lt;image&gt;:&lt;tag&gt;</p>
<p>•维护者信息: MAINTAINER （建议使用LABEL标签进行替代,先已丢弃）</p>
<p>•镜像标签信息: LABEL</p>
<p>•镜像操作指令: RUN</p>
<p>•容器启动时执行指令: CMD</p>
<p>在编写完成Dockerfile之后可以通过docker build 命令来创建镜像,该命令读取指定路径下(包括子目录)的dockerfile(实际上是构建上下文Context),并将该路径下的内容发送给Docker服务端由它创建镜像; 因此一般建议放置Dockerfile的目录为空另外可以通过dockerignore文件(每一行添加一条匹配模式)会让Docker忽略路径下的目录和文件</p>
<h3 id="docker-镜像生成常用命令"><a href="#docker-镜像生成常用命令" class="headerlink" title="docker 镜像生成常用命令"></a>docker 镜像生成常用命令</h3><p>docker build [选项]</p>
<ul>
<li>t ：指定标签信息</li>
</ul>
<p>–build-arg &lt;参数名&gt;&#x3D;&lt;值&gt;</p>
<h3 id="构建镜像的几种方式"><a href="#构建镜像的几种方式" class="headerlink" title="构建镜像的几种方式:"></a>构建镜像的几种方式:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker build [选项]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-t ：指定标签信息</span></span><br><span class="line"><span class="comment">#--build-arg &lt;参数名&gt;=&lt;值&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#构建镜像的几种方式: </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1) 指定的Dockfile所在路径为/tmp/docker_builder</span></span><br><span class="line">$docker build -t [TAG/version] /tmp/docker_builder</span><br><span class="line"></span><br><span class="line"><span class="comment">#2) 支持从 URL 构建</span></span><br><span class="line">$docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:11.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3) 用给定的 tar 压缩包构建</span></span><br><span class="line">$docker build http://server/context.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#4) 从标准输入中读取 Dockerfile 进行构建</span></span><br><span class="line">$docker build - &lt; Dockerfile</span><br><span class="line">$cat Dockerfile | docker build -</span><br><span class="line"></span><br><span class="line"><span class="comment">#5) 从标准输入中读取上下文压缩包进行构建</span></span><br><span class="line"><span class="comment">#标准输入的文件格式还可以是 gzip、bzip2 以及 xz </span></span><br><span class="line">$docker build - &lt; context.tar.gz   </span><br></pre></td></tr></table></figure>

<h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><h4 id="FROM-基础镜像信息"><a href="#FROM-基础镜像信息" class="headerlink" title="FROM - 基础镜像信息"></a>FROM - 基础镜像信息</h4><p>描述:</p>
<p>尽可能使用官方镜像或者信任的镜像作为你构建镜像的基础设施,推荐使用<a target="_blank" rel="noopener" href="https://hub.docker.com/_/alpine/">Alpine</a>镜像，因为它被严格控制并保持最小尺寸（目前小于 6 MB），但它仍然是一个完整的发行版。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础语法</span></span><br><span class="line"></span><br><span class="line">FROM &lt;image&gt; 或者 FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用案例</span></span><br><span class="line"></span><br><span class="line">FROM alpine</span><br><span class="line">FROM golang:<span class="number">1.9</span>-alpine <span class="keyword">as</span> builder <span class="comment"># 注意：多阶段构建使用 as 来为某一阶段命名 </span></span><br></pre></td></tr></table></figure>

<h4 id="LABEL-标签信息"><a href="#LABEL-标签信息" class="headerlink" title="LABEL - 标签信息"></a>LABEL - 标签信息</h4><p>描述:</p>
<p>可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等</p>
<p>注意:如果你的字符串包含空格，那么它必须被引用或者空格必须被转义。如果您的字符串包含内部引号字符（”），则也可以将其转义。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础语法:每个标签一行，由 LABEL 开头加上一个或多个标签对。</span></span><br><span class="line"></span><br><span class="line">LABEL key=&lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用案例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Set one or more individual labels `#`开头的行是注释内容。</span></span><br><span class="line"></span><br><span class="line">LABEL maintainer=<span class="string">&quot;WeiyiGeek&quot;</span></span><br><span class="line">LABEL vendor=<span class="string">&quot;ACME Incorporated&quot;</span></span><br><span class="line">LABEL version=<span class="number">1.1</span></span><br><span class="line">LABEL com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span></span><br><span class="line">LABEL com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span> </span><br></pre></td></tr></table></figure>

<p>在 1.10 之前，建议将所有标签合并为一条LABEL指令，以防止创建额外的层，但是现在这个不再是必须的了 </p>
<h4 id="MAINTAINER-维护者信息"><a href="#MAINTAINER-维护者信息" class="headerlink" title="MAINTAINER - 维护者信息"></a>MAINTAINER - 维护者信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础语法</span></span><br><span class="line"></span><br><span class="line">MAINTAINER key=&lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用案例</span></span><br><span class="line"></span><br><span class="line">MAINTAINER WeiyiGeek master@weiyigeek.top </span><br></pre></td></tr></table></figure>

<h4 id="RUN-镜像操作命令"><a href="#RUN-镜像操作命令" class="headerlink" title="RUN - 镜像操作命令"></a>RUN - 镜像操作命令</h4><p>描述:</p>
<p>为了保持 Dockerfile 文件的可读性，以及可维护性，建议将长的或复杂的RUN指令用反斜杠\分割成多行。</p>
<p>RUN 指令最常见的用法是安装包用的apt-get,因为该指令会安装包 </p>
<p>有几个问题需要注意 ：</p>
<ul>
<li>不要使用 RUN apt-get upgrade 或 dist-upgrade , 如果基础镜像中的某个包过时了，你应该联系它的维护者。</li>
<li>如果你确定某个特定的包比如 foo 需要升级，使用 apt-get install -y foo 就行，该指令会自动升级 foo 包。</li>
<li>最好将 RUN 多条语句汇集成为一条 apt-get update 和 apt-get install 以及 rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists* 组合成一条 RUN 声明</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础语法</span></span><br><span class="line"></span><br><span class="line">RUN &lt;COMMAND&gt; 或者 RUN [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用案例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如：RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo Hello&quot;],当命令较长时可以使用\来换行;</span></span><br><span class="line">RUN apt-get update;\</span><br><span class="line">    apt-get install -y nginx ;\</span><br><span class="line">    rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"><span class="comment">#展示了所有关于 apt-get 的建议</span></span><br><span class="line"><span class="comment">#其中 s3cmd 指令指定了一个版本号`1.1.*`。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 apt-get udpate 缓存失效并确保安装的是新版本。</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y \</span><br><span class="line">    aufs-tools \</span><br><span class="line">    automake \</span><br><span class="line">    build-essential \</span><br><span class="line">    curl \</span><br><span class="line">    dpkg-sig \</span><br><span class="line">    libcap-dev \</span><br><span class="line">    libsqlite3-dev \</span><br><span class="line">    mercurial \</span><br><span class="line">    reprepro \</span><br><span class="line">    ruby1<span class="number">.9</span><span class="number">.1</span> \</span><br><span class="line">    ruby1<span class="number">.9</span><span class="number">.1</span>-dev \</span><br><span class="line">    s3cmd=<span class="number">1.1</span>.* \</span><br><span class="line"> &amp;&amp; rm -rf /var/lib/apt/lists/* </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202270952025.png" alt="image-20220227095244915"></p>
<h4 id="CMD-容器启动时执行指令"><a href="#CMD-容器启动时执行指令" class="headerlink" title="CMD- 容器启动时执行指令"></a>CMD- 容器启动时执行指令</h4><p>描述:</p>
<p>指令用于执行目标镜像中包含的软件和任何参数, 实际上为容器提供一个默认的执行命令。</p>
<p><strong><u>在Dockerfile中CMD被用来为ENTRYPOINT指令提供参数，则CMD和ENTRYPOINT指令都应该使用exec格式</u></strong></p>
<p>当基于镜像的容器运行时将会自动执行CMD指令, 并且如果在docker run命令中指定了参数，这些参数将会覆盖在CMD指令中设置的参数。</p>
<p>多数情况下CMD 都需要一个交互式的 shell (bash, Python, perl 等)，例如 CMD [“perl”, “-de0”]，或者 CMD [“PHP”, “-a”]。使用这种形式意味着，当你执行类似docker run -it python时，你会进入一个准备好的 shell 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础语法</span></span><br><span class="line"><span class="comment">#CMD指令有如下三种格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#exec格式</span></span><br><span class="line">CMD [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span><br><span class="line"><span class="comment">#为ENTRYPOINT提供参数</span></span><br><span class="line">CMD [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span><br><span class="line"><span class="comment">#shell格式,在/bin/bash中执行提供给需要交互的应用</span></span><br><span class="line">CMD command param1 param2</span><br><span class="line"></span><br><span class="line"><span class="comment">#基础示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#(1)如果创建镜像的目的是为了部署某个服务(比如 Apache)</span></span><br><span class="line">CMD [<span class="string">&quot;apache2&quot;</span>, <span class="string">&quot;-DFOREGROUND&quot;</span>]</span><br><span class="line"><span class="comment">#(2)如果使用 shell 格式的话,实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：</span></span><br><span class="line">CMD echo $HOME <span class="comment">#在实际执行中,会将其变更为： CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ] </span></span><br></pre></td></tr></table></figure>

<p>注意事项:</p>
<p>(1)如果用户启动容器指定了运行命令则会覆盖掉CMD指定命令,<strong><u>注意每个Dockerfile只能有一条CMD命令,如果指定了多条命令只有最后一条执行;</u></strong></p>
<p>(2)CMD 在极少的情况下才会以 CMD [“param”, “param”] 的形式与ENTRYPOINT协同使用，除非你和你的镜像使用者都对 ENTRYPOINT 的工作方式十分熟悉。</p>
<h4 id="EXPOSE-端口映射指令"><a href="#EXPOSE-端口映射指令" class="headerlink" title="EXPOSE - 端口映射指令"></a>EXPOSE - 端口映射指令</h4><p> 描述:</p>
<p>EXPOSE指令用于指定容器将要监听的端口即默认向外部的暴露的服务端口。因此你应该为你的应用程序使用常见的端口。<br>对于外部访问，用户可以在执行 docker run 时使用一个标志来指示如何将指定的端口映射到所选择的端口。 </p>
<p>#基础语法<br>EXPOSE <port> [<port>…]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#(1) 告诉dokcer服务端容器暴露的端口号,供互联系统使用; 也就是 docker run -P 时会自动随机映射 EXPOSE 的端口。</span></span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">22</span> <span class="number">80</span> <span class="number">8443</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#(2) 例如提供 Apache web 服务的镜像应该使用 80，而提供 MongoDB 服务的镜像使用 27017</span></span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">80</span> <span class="number">27017</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#(3) 指定一个范围</span></span><br><span class="line"></span><br><span class="line">EXPOSE <span class="number">30000</span>-<span class="number">40000</span> </span><br></pre></td></tr></table></figure>



<h4 id="ENV-修改环境变量指令"><a href="#ENV-修改环境变量指令" class="headerlink" title="ENV - 修改环境变量指令"></a>ENV - 修改环境变量指令</h4><p>描述:</p>
<p>为了方便新程序运行，你可以使用ENV来为容器中安装的程序更新 PATH 环境变量。例如使用ENV PATH &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;bin:$PATH来确保CMD [“nginx”]能正确运行。类似于程序中的常量，该方法可以让你只需改变 ENV 指令来自动的改变容器中的软件版本。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础语法</span></span><br><span class="line"></span><br><span class="line">ENV &lt;key&gt; &lt;value&gt;   <span class="comment">#会被后续的RUN指令使用,并在容器运行时保持;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#基础示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方式1: 如RUN还是运行时的应用，都可以直接使用这里定义的环境变量。</span></span><br><span class="line">ENV PG_MAJOR <span class="number">9.3</span></span><br><span class="line">ENV PATH /usr/local/postgres-\$PG_MAJOR/<span class="built_in">bin</span>:$PATH</span><br><span class="line">RUN curl -SL http://example.com/postgre-$PG_MAJOR.tar.xz  &amp;&amp; ENV PATH /usr/local/postgres-$PG_MAJOR/<span class="built_in">bin</span>:$PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#方式2: 将所有的环境变量定义在一条ENV语句中</span></span><br><span class="line">ENV VERSION=<span class="number">1.0</span> DEBUG=on \</span><br><span class="line">    NAME=<span class="string">&quot;Happy Feet&quot;</span> </span><br></pre></td></tr></table></figure>



<h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG - 构建参数"></a>ARG - 构建参数</h4><p>描述:</p>
<p>构建参数和 ENV 的效果一样都是设置环境变量不同点就是容器构建完成则失效</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;参数名&gt; [=&lt;默认值&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用方式与Shell中一致</span></span><br><span class="line"></span><br><span class="line">$&#123;IMG_PATH&#125; </span><br></pre></td></tr></table></figure>



<h4 id="ADD-添加指定目录文件到镜像指令"><a href="#ADD-添加指定目录文件到镜像指令" class="headerlink" title="ADD - 添加指定目录文件到镜像指令"></a>ADD - 添加指定目录文件到镜像指令</h4><p>描述:</p>
<p>该命令将复制指定的源文件<src>到镜像内中的目标文件<dest>,其中<src>可以是在Dockerfile所在的目录的一个相对路径(文件或者目录)&#x2F;URL&#x2F;tar文件（本地 tar 提取和远程 URL 支持） </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础语法</span></span><br><span class="line"></span><br><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#基础示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#(1)最佳用例是将本地tar文件自动提取到镜像中</span></span><br><span class="line"></span><br><span class="line">ADD rootfs.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment">#(2)下载后的文件权限自动设置为 600 这个自动解压缩的功能非常有用；</span></span><br><span class="line"></span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz</span><br><span class="line">ADD --chown=<span class="number">55</span>:mygroup files* /mydir/ </span><br></pre></td></tr></table></figure>

<p>注意事项:</p>
<p>(1)为了让镜像尽量小，最好不要使用 ADD 指令从远程 URL 获取包，而是使用 curl 和 wget。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层</span></span><br><span class="line"><span class="comment">#比如尽量避免下面的用法：</span></span><br><span class="line">ADD http://example.com/big.tar.xz /usr/src/things/</span><br><span class="line">RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span><br><span class="line">RUN make -C /usr/src/things <span class="built_in">all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#而是应该使用下面这种方法：由于使用的管道操作，所以没有中间文件需要删除。</span></span><br><span class="line">RUN mkdir -p /usr/src/things \</span><br><span class="line">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span><br><span class="line">    | tar -xJC /usr/src/things \</span><br><span class="line">    &amp;&amp; make -C /usr/src/things <span class="built_in">all</span> </span><br></pre></td></tr></table></figure>



<h4 id="COPY-复制指定文件或者目录到容器中"><a href="#COPY-复制指定文件或者目录到容器中" class="headerlink" title="COPY - 复制指定文件或者目录到容器中"></a>COPY - 复制指定文件或者目录到容器中</h4><p>描述:</p>
<p>COPY只支持简单将本地文件拷贝到镜像中它比 ADD 更透明,所以ADD和COPY功能类似但一般优先使用 COPY ;</p>
<p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件&#x2F;目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。</p>
<p>当目标路径不存在时候自动创建,当使用本地目录作为源目录时候推荐使用COPY: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础语法</span></span><br><span class="line"></span><br><span class="line">COPY &lt;src&gt; &lt;dest&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#选项</span></span><br><span class="line"></span><br><span class="line">--<span class="keyword">from</span>=多阶段构建的镜像名称 <span class="comment">#FROM Alpine AS [名称]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#常规方式</span></span><br><span class="line"></span><br><span class="line">COPY package.json /usr/src/app/</span><br><span class="line"><span class="comment">#&lt;源路径&gt; 可以是多个,甚至可以是通配符</span></span><br><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br><span class="line"></span><br><span class="line"><span class="comment">#选项来改变文件的所属用户及所属组。</span></span><br><span class="line"></span><br><span class="line">COPY --chown=<span class="number">55</span>:mygroup files* /mydir/</span><br><span class="line">COPY --<span class="keyword">from</span>=<span class="number">0</span> /go/src/github.com/go/helloworld/app .  <span class="comment">#多阶段构建，从上一阶段的镜像中复制文件</span></span><br><span class="line">COPY --<span class="keyword">from</span>=nginx:latest /etc/nginx/nginx.conf /nginx.conf  <span class="comment">#复制任意镜像中的文件（但需要指定镜像名称 )</span></span><br></pre></td></tr></table></figure>

<p>Tips:</p>
<p>对于其他不需要 ADD 的自动提取功能的文件或目录，你应该使用 COPY。</p>
<p>采用CPOY –from 从上一个构建阶段拷贝文件时，使用的路径是相对于上一阶段的根目录的，此时建议复制成果时候采用绝对路径; </p>
<h4 id="ENTRYPOINT-配置容器启动进入后的执行命令-应用运行前的准备工作"><a href="#ENTRYPOINT-配置容器启动进入后的执行命令-应用运行前的准备工作" class="headerlink" title="ENTRYPOINT - 配置容器启动进入后的执行命令-应用运行前的准备工作"></a>ENTRYPOINT - 配置容器启动进入后的执行命令-应用运行前的准备工作</h4><p>描述: </p>
<p>该指令是设置镜像的主命令，其作用是允许将镜像当成命令本身来运行（使用终端提供默认选项） </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基础示例</span></span><br><span class="line"><span class="comment">#exec格式推荐的格式</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span><br><span class="line"><span class="comment">#shell格式:使用ENTRYPONT指令并不可被docker run提供的参数覆盖(与CMD不同之处)</span></span><br><span class="line">ENTRYPOINT command param1 param2    <span class="comment">#shell中执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础示例</span></span><br><span class="line"><span class="comment"># 1.例如下面的示例镜像提供了命令行工具 s3cmd:</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;s3cmd&quot;</span>]</span><br><span class="line">CMD [<span class="string">&quot;--help&quot;</span>]</span><br><span class="line"><span class="comment">#现在直接运行该镜像创建的容器会显示命令帮助: $ docker run s3cmd</span></span><br><span class="line"><span class="comment">#或者提供正确的参数来执行某个命令：$ docker run s3cmd ls s3://mybucket</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.使用ENTRYPOINT 的exec形式来设置相对稳定的默认命令和参数，然后使用任何形式的CMD指令来设置可能发生变化的参数。</span></span><br><span class="line">FROM alpine</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;top&quot;</span>, <span class="string">&quot;-b&quot;</span>]</span><br><span class="line">CMD [<span class="string">&quot;-c&quot;</span>]</span><br><span class="line"><span class="comment">#当运行容器是，可以看到只有一个top进程在运行：</span></span><br><span class="line">$ docker run -it --rm --name alpine:test top -H</span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">  <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">19744</span>   <span class="number">2336</span>   <span class="number">2080</span> R  <span class="number">0.0</span>  <span class="number">0.1</span>   <span class="number">0</span>:<span class="number">00.04</span> top</span><br><span class="line">$ docker <span class="built_in">exec</span> -it alpine:test ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         <span class="number">1</span>  <span class="number">2.6</span>  <span class="number">0.1</span>  <span class="number">19752</span>  <span class="number">2352</span> ?        Ss+  08:<span class="number">24</span>   <span class="number">0</span>:<span class="number">00</span> top -b -H</span><br><span class="line">root         <span class="number">7</span>  <span class="number">0.0</span>  <span class="number">0.1</span>  <span class="number">15572</span>  <span class="number">2164</span> ?        R+   08:<span class="number">25</span>   <span class="number">0</span>:<span class="number">00</span> ps aux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.ENTRYPOINT指令的shell格式</span></span><br><span class="line"><span class="comment">#通过为ENTRYPOINT指定文本格式的参数，此参数将在`/bin /sh -c` 中进行执行</span></span><br><span class="line"><span class="comment">#该形式将使用shell处理而不是shell环境变量，并且将忽略任何的CMD或docker run运行命令行参数。</span></span><br><span class="line">FROM alpine</span><br><span class="line">ENTRYPOINT <span class="built_in">exec</span> top -b </span><br></pre></td></tr></table></figure>

<p>补充说明:</p>
<p>1.ENTRYPOINT 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。 </p>
<p>2.通过ENTRYPOINT指令可以将容器设置作为可执行的文件</p>
<p> 注意：当指定多个ENTRYPOINT时候只有最后一个生效; </p>
<h4 id="VOLUME-创建本地主机或其他主机挂载点-定义匿名卷"><a href="#VOLUME-创建本地主机或其他主机挂载点-定义匿名卷" class="headerlink" title="VOLUME- 创建本地主机或其他主机挂载点-定义匿名卷"></a>VOLUME- 创建本地主机或其他主机挂载点-定义匿名卷</h4><p>描述:</p>
<p>指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 VOLUME来管理镜像中的可变部分和用户可以改变的部分。</p>
<ul>
<li>VOLUME指令只是起到了声明了容器中的目录作为匿名卷，但是并没有将匿名卷绑定到宿主机指定目录的功能;</li>
<li>镜像run了一个容器的时候，docker会在安装目录下的指定目录下面生成一个目录来绑定容器的匿名卷（这个指定目录不同版本的docker会有所不同）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础示例:</span></span><br><span class="line">VOLUME [<span class="string">&quot;&lt;路径1&gt;&quot;</span>, <span class="string">&quot;&lt;路径2&gt;&quot;</span>...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例:</span></span><br><span class="line"><span class="comment">#一般用来存放数据和需要保持的数据等,在运行的时候我们就可以利用 -v /Store/data(宿主机):/date(容器),数据就可以直接存在在宿主机上面;</span></span><br><span class="line">VOLUME [<span class="string">&quot;/data&quot;</span>] 作者：WeiyiGeek https://www.bilibili.com/read/cv15220707 出处：bilibili</span><br></pre></td></tr></table></figure>

<h4 id="USER-指定容器运行时名用户名或者UID"><a href="#USER-指定容器运行时名用户名或者UID" class="headerlink" title="USER- 指定容器运行时名用户名或者UID"></a>USER- 指定容器运行时名用户名或者UID</h4><p>描述:</p>
<p>如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户。 </p>
<p>注意事项：</p>
<p>1.在镜像中用户和用户组每次被分配的 UID&#x2F;GID 都是不确定的，下次重新构建镜像时被分配到的 UID&#x2F;GID 可能会不一样。<br>如果要依赖确定的 UID&#x2F;GID 你应该显示的指定一个 UID&#x2F;GID。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1</span></span><br><span class="line">RUN groupadd -r postgres -g <span class="number">1001</span> &amp;&amp; useradd -r -g postgres postgres -u <span class="number">1001</span></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line">RUN useradd -r -u <span class="number">1001</span> -U postgres </span><br></pre></td></tr></table></figure>

<p>2.应该避免使用 sudo 命令因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 sudo 类似的功能（例如以 root 权限初始化某个守护进程，以非 root 权限执行它）你可以使用 gosu 命令; 最后为了减少层数和复杂度，避免频繁地使用 USER 来回切换用户。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础示例</span></span><br><span class="line"><span class="comment">#(1) 当服务不需要管理员权限时,可以通过该命令指定运行用户,并且可以在之前创建所需要的用户</span></span><br><span class="line">USER daemon</span><br><span class="line"></span><br><span class="line"><span class="comment">#(2)要临时获取管理员权限可以使用gosu而不使用sudo;</span></span><br><span class="line"><span class="comment">#USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</span></span><br><span class="line">RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span><br><span class="line">USER postgres</span><br></pre></td></tr></table></figure>



<h4 id="WORKDIR-配置工作目录"><a href="#WORKDIR-配置工作目录" class="headerlink" title="WORKDIR - 配置工作目录"></a>WORKDIR - 配置工作目录</h4><p>描述:为了清晰性和可靠性，你应该总是在WORKDIR中使用绝对路径。另外你应该使用 WORKDIR 来替代类似于 RUN cd … &amp;&amp; do-something 的指令，后者难以阅读、排错和维护。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础示例</span></span><br><span class="line"><span class="comment">#(1)为后续的RUN CMD ENTRYPOINT 指令配置工作目录</span></span><br><span class="line">WORKDIR /path/to/workdir</span><br><span class="line"></span><br><span class="line"><span class="comment">#(2)使用多个WORKDIR指令，如果后续命令参数是相对路径，则会基于首个绝对路径进行拼接。</span></span><br><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR C</span><br><span class="line">RUN pwd  <span class="comment">#最终路径是/a/b/c </span></span><br></pre></td></tr></table></figure>



<h4 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD - 为他人做嫁衣裳"></a>ONBUILD - 为他人做嫁衣裳</h4><p>描述:ONBUILD是一个特殊的指令在当前镜像构建时并不会被执行。**<u>只有当以当前镜像为基础镜像去构建下一级镜像的时候才会被执行</u>**。它后面跟的是其它指令比如 RUN, COPY 等</p>
<p><strong><u>Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。</u></strong> </p>
<h4 id="STOPSIGNAL-指定所创建镜像启动的容器接收退出的信号值"><a href="#STOPSIGNAL-指定所创建镜像启动的容器接收退出的信号值" class="headerlink" title="STOPSIGNAL - 指定所创建镜像启动的容器接收退出的信号值"></a>STOPSIGNAL - 指定所创建镜像启动的容器接收退出的信号值</h4><p>描述: 该指令设置将发送到的系统调用信号容器退出，如果不定义信号名称默认是 SIGTERM。<br>此信号可以是格式中的 SIG <NAME>, 例如 SIGKILL，或与 例如内核的系统调用表 9 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">STOPSIGNAL signal </span><br></pre></td></tr></table></figure>



<h4 id="SHELL-指定其他命令执行时默认使用shell的类型"><a href="#SHELL-指定其他命令执行时默认使用shell的类型" class="headerlink" title="SHELL - 指定其他命令执行时默认使用shell的类型"></a>SHELL - 指定其他命令执行时默认使用shell的类型</h4><p>描述: </p>
<p>该指令允许使用 shell 形式覆盖命令,</p>
<ul>
<li>Linux中默认的Shell是[“&#x2F;bin&#x2F;sh”, “-c”]</li>
<li>Windows中默认的Shell是[“cmd”, “&#x2F;S”, “&#x2F;C”]</li>
<li>如果Linux中还存在备用的shell例如（zsh、csh、tcsh），我们也可以采用此种方法指定。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实际示例</span></span><br><span class="line">SHELL [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>]</span><br><span class="line">SHELL [<span class="string">&quot;powershell&quot;</span>,<span class="string">&quot;-command&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实践使用示例</span></span><br><span class="line">FROM microsoft/nanoserver</span><br><span class="line">SHELL [<span class="string">&quot;powershell&quot;</span>,<span class="string">&quot;-command&quot;</span>]</span><br><span class="line">RUN New-Item -ItemType Directory C:\Example</span><br><span class="line">ADD Execute-MyCmdlet.ps1 c:\example\</span><br><span class="line">RUN c:\example\Execute-MyCmdlet -sample <span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK - 健康检查"></a>HEALTHCHECK - 健康检查</h4><p>描述:该命令设置检查容器健康状况的命令,它与 kubernetes 中的 Pod 探针类似</p>
<p>在没有 HEALTHCHECK 指令前Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。</p>
<p>在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>从 Docker 1.12 引入该指令HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础语法</span></span><br><span class="line"><span class="comment">#命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。</span></span><br><span class="line">HEALTHCHECK [选项] CMD &lt;命令&gt;</span><br><span class="line"><span class="comment"># 选项：</span></span><br><span class="line">--interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 <span class="number">30</span> 秒；</span><br><span class="line">--timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间本次健康检查就被视为失败默认 <span class="number">30</span> 秒；</span><br><span class="line">--retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 <span class="number">3</span> 次。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span></span><br><span class="line">HEALTHCHECK NONE </span><br></pre></td></tr></table></figure>

<h2 id="Docker容器文件系统"><a href="#Docker容器文件系统" class="headerlink" title="Docker容器文件系统"></a>Docker容器文件系统</h2><ul>
<li>Docker 镜像代表了容器的文件系统里的内容，是容器的基础，镜像一般是通过 Dockerfile 生成的</li>
<li>Docker 的镜像是分层的，所有的镜像（除了基础镜像）都是在之前镜像的基础上加上自己这层的内容生成的</li>
<li>Docker 中每一层镜像的元数据都是存在 json 文件中的，除了静态的文件系统之外，还会包含动态的数据</li>
<li>Docker 镜像生产容器后会在此基础之上加入挂载点到安装Docker宿主机文件系统之中，并提供一个读写层(Read-Write Layer)，所以容器进程的所有操作都在读写层进行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202271016159.webp" alt="1df77b34c33c40f050fe76c25004e8599fdc09e6.png@942w_581h_progressive"></p>
<h2 id="Volume-数据卷"><a href="#Volume-数据卷" class="headerlink" title="Volume 数据卷"></a>Volume 数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对 数据卷 的修改会立马生效</li>
<li>对 数据卷的更新，不会影响镜像</li>
<li>数据卷 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<h3 id="容器中管理数据的主要两种方式"><a href="#容器中管理数据的主要两种方式" class="headerlink" title="容器中管理数据的主要两种方式"></a>容器中管理数据的主要两种方式</h3><ul>
<li>数据卷： Data Volumes</li>
<li>数据卷容器： Data Volume Dontainers</li>
</ul>
<h3 id="数据管理共享的方式"><a href="#数据管理共享的方式" class="headerlink" title="数据管理共享的方式"></a>数据管理共享的方式</h3><ul>
<li>使用数据卷容器在容器和主机</li>
<li>容器和容器之间共享数据</li>
</ul>
<h3 id="数据卷命令行"><a href="#数据卷命令行" class="headerlink" title="数据卷命令行"></a>数据卷命令行</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去</p>
<p>本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p>
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">    --name web \</span><br><span class="line">    <span class="comment"># -v /src/webapp:/usr/share/nginx/html \</span></span><br><span class="line">    --mount <span class="built_in">type</span>=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly\</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>

<p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it \</span><br><span class="line">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span><br><span class="line">   --mount <span class="built_in">type</span>=bind,source=$HOME/.bash_history,target=/root/.bash_history \</span><br><span class="line">   ubuntu:<span class="number">18.04</span> \</span><br><span class="line">   bash</span><br><span class="line"></span><br><span class="line">root@2affd44b4667:/<span class="comment"># history</span></span><br><span class="line"><span class="number">1</span>  ls</span><br><span class="line"><span class="number">2</span>  diskutil <span class="built_in">list</span></span><br></pre></td></tr></table></figure>





<p>？： mount和–volumes-from的关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个数据卷</span></span><br><span class="line">$ docker volume create my-vol</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有数据卷</span></span><br><span class="line">$ docker volume ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看指定数据卷的信息</span></span><br><span class="line">$ docker volume inspect my-vol</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 创建一个web容器并创建一个数据卷挂载到容器的/webapp目录下(默认将宿主机/根映射到容器中webapp目录中)</span></span><br><span class="line">$ sudo docker run -d -P <span class="number">5000</span> --name web(新建容器) -v /webapp(容器目录) training/webapp(镜像) python app.py</span><br><span class="line"><span class="comment"># --name 指定容器的名称</span></span><br><span class="line"><span class="comment"># -v:将镜像的存放位置放在本地指定的路径上.</span></span><br><span class="line"><span class="comment"># -P:是允许外部访问容器需要暴露的port</span></span><br><span class="line"><span class="comment"># -d:是容器的后台运行守护</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cp 把容器文件copy到宿主机,或者把宿主机的文件copy到容器</span></span><br><span class="line"><span class="comment">#把容器的1.php拷贝到宿主机家目录</span></span><br><span class="line">$docker cp 容器<span class="built_in">id</span>或者name:/home/wwwroot/<span class="number">1.</span>php /home/Lcy/ </span><br><span class="line"><span class="comment">#把宿主机的config.php拷贝到容器 </span></span><br><span class="line">$docker cp config.php 容器<span class="built_in">id</span>或者name:/home/wwwroot/  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#挂载主机目录/文件作为数据卷：</span></span><br><span class="line"><span class="comment">#挂载一个主机目录作为数据卷 /src/webapp[主机目录]:/opt/webapp[容器目录]:rw (权限)</span></span><br><span class="line">$ sudo docker run -d -P --name web -v  /src/webapp:/opt/webapp:rw training/webapp python app.py</span><br><span class="line"><span class="comment"># Docker挂载数据卷的默认权限 rw,ro[只读]          //加入ro后数据卷的数据就无法修改了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载一个本地文件作为数据卷（注意再挂载文件得时候尽量设置ro自读,防止inode不一致报错）</span></span><br><span class="line">$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /<span class="built_in">bin</span>/bash</span><br><span class="line"><span class="comment"># --rm ：当它退出自动移除容器 即docker ps -aq 不能查询到 </span></span><br></pre></td></tr></table></figure>

<h3 id="数据卷容器命令行"><a href="#数据卷容器命令行" class="headerlink" title="数据卷容器命令行"></a>数据卷容器命令行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先创建一个数据卷容器dbdata并在其中创建一个数据卷挂载到/dbdata上 </span></span><br><span class="line">$ sudo docker run -it -v /dbdate --name dbdate ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后在容器中进行使用 创建两个容器db1 / db2</span></span><br><span class="line">$ sudo docker run -it --volumes-<span class="keyword">from</span> dbdate --name db1 ubuntu</span><br><span class="line">$ sudo docker run -it --volumes-<span class="keyword">from</span> dbdate --name db2 ubuntu</span><br><span class="line"><span class="comment">#使用--volumes-from参数所挂载数据卷的容器自身并不需要保持运行状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改目录中其中任何一个文件,其他容器的该目录都会改变</span></span><br><span class="line"><span class="comment">#可以从已有挂载了容器卷的容器来挂载数据卷</span></span><br><span class="line">$ sudo docker run -d --name db2 --volumes-<span class="keyword">from</span> db1 tarining/postgresql      </span><br><span class="line"><span class="comment">#删除挂载的容器(dbdata 、 db1 、db2)数据卷饼不会被自动的删除,必须在删除最后一个挂载着它容器时显示使用Docker rm -v 命令来指定同时删除关联的容器； </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数据卷容器迁移数据"><a href="#数据卷容器迁移数据" class="headerlink" title="数据卷容器迁移数据"></a>数据卷容器迁移数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##可以利用数据卷容器对其中的数据卷进行备份、恢复以实现数据的迁移 </span></span><br><span class="line"><span class="comment">#备份: 创建一个worker容器 ,将本地当前目录挂载到容器中backup目录,进行选择数据目录备份压缩</span></span><br><span class="line">$ sudo docker run --volumes-<span class="keyword">from</span> dbdata -v $(pwd):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdate</span><br><span class="line"></span><br><span class="line"><span class="comment">#恢复: 首先创建一个带有数据卷的容器dbdata2</span></span><br><span class="line">$ sudo docker run -v /dbdata --name dbdata2 ubuntu /<span class="built_in">bin</span>/bash</span><br><span class="line"><span class="comment">#解压备份文件到挂载的数据卷中</span></span><br><span class="line">$ sudo docker run --volumes-<span class="keyword">from</span> dbdata2 $(pwd):/backup busybox tar xvf /backup/backup.tar </span><br></pre></td></tr></table></figure>

<h3 id="Z和z的区别"><a href="#Z和z的区别" class="headerlink" title="Z和z的区别"></a>Z和z的区别</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置selinux标签如果使用selinux，可以添加z或z选项来修改挂载到容器中的主机文件或目录的selinux标签</span></span><br><span class="line"><span class="comment">#:z选项指示绑定挂载内容在多个容器之间共享。</span></span><br><span class="line"><span class="comment">#:Z选项表示绑定挂载内容是私有和非共享的。</span></span><br><span class="line"><span class="comment">#重要:当使用绑定与服务挂载时，selinux标签(:z和:Z)以及:ro将被忽略,设置了z选项以指定多个容器可以共享绑定挂载的内容,此时不能使用——mount标记修改selinux标签</span></span><br><span class="line">docker run -d --restart=always --name app-v /disk/webapp/war/:/usr/local/tomcat/webapps:z -p <span class="number">4081</span>:<span class="number">8080</span> -e JAVA_OPTS=-Dsome.<span class="built_in">property</span>=value -e Xmx=1536m tomcat-base:<span class="number">6.0</span><span class="number">.85</span>-jre8 </span><br></pre></td></tr></table></figure>

<h3 id="总结说明"><a href="#总结说明" class="headerlink" title="总结说明"></a>总结说明</h3><ul>
<li>推荐直接挂载文件目录到容器中,如果直接挂载一个文件到容器中在使用文本编辑工具时候可能会报错;</li>
<li>可以多次使用–volumes-from参数从来多个容器挂载多个数据卷;锁挂载的容器自身并不需要保持在运行状态</li>
<li>推荐使用数据卷和数据容器之外的物理备份存储系统,如RAID或者分布式系统如Ceph,GPFS,HDFS等</li>
</ul>
<h2 id="联合文件系统（UnionFS"><a href="#联合文件系统（UnionFS" class="headerlink" title="联合文件系统（UnionFS)"></a>联合文件系统（UnionFS)</h2><p>联合文件系统（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p>
<p>在可能的情况下，<a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">推荐</a> 使用 <code>overlay2</code> 存储驱动，<code>overlay2</code> 是目前 Docker 默认的存储驱动，以前则是 <code>aufs</code>。你可以通过配置来使用以上提到的其他类型的存储驱动。</p>
<p>Question:存储驱动</p>
<p>Question:engine</p>
<p>Question: 容器格式</p>
<h2 id="Docker-Compose-（需要加强学习）"><a href="#Docker-Compose-（需要加强学习）" class="headerlink" title="Docker Compose （需要加强学习）"></a>Docker Compose （需要加强学习）</h2><p>Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）</p>
<p>Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责实现对 Docker 容器集群的快速编排。</p>
<p>它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p>
<h4 id="Docker-Compose重要概念"><a href="#Docker-Compose重要概念" class="headerlink" title="Docker Compose重要概念"></a>Docker Compose重要概念</h4><ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose来进行编排管理。</p>
<h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。</p>
<p>Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</p>
<p>Docker Machine 管理的虚拟主机可以是机上的，也可以是云供应商，如阿里云，腾讯云，AWS，或 DigitalOcean。</p>
<p>使用 docker-machine 命令，您可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。</p>
<p><img src="https://raw.githubusercontent.com/HenryVarro666/images/master/images/202202271110444.png" alt="image-20220227111032314"></p>
<h2 id="容器连接"><a href="#容器连接" class="headerlink" title="容器连接"></a>容器连接</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv15185166?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv15185166?spm_id_from=333.999.0.0</a></p>
<p>Question：网络连接的原理</p>
<h3 id="实现通过端口连接到一个docker容器"><a href="#实现通过端口连接到一个docker容器" class="headerlink" title="实现通过端口连接到一个docker容器"></a>实现通过端口连接到一个docker容器</h3><p>网络端口映射</p>
<ul>
<li><strong>-P :<strong>是容器内部端口</strong>随机</strong>映射到主机的端口。</li>
<li><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建了一个 python 应用的容器</span></span><br><span class="line">runoob@runoob:~$ docker run -d -P training/webapp python app.py</span><br><span class="line"><span class="comment"># 另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</span></span><br><span class="line"><span class="comment">#我们使用 -P 绑定端口号，使用 docker ps 可以看到容器端口 5000 绑定主机端口 32768</span></span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID    IMAGE               COMMAND            ...           PORTS                     NAMES</span><br><span class="line">fce072cc88ce    training/webapp     <span class="string">&quot;python app.py&quot;</span>    ...     <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">32768</span>-&gt;<span class="number">5000</span>/tcp   grave_hopper</span><br><span class="line"><span class="comment">#我们也可以使用 -p 标识来指定容器端口绑定到主机端口。</span></span><br><span class="line"><span class="comment">#-P :是容器内部端口随机映射到主机的端口。</span></span><br><span class="line"><span class="comment">#-p : 是容器内部端口绑定到指定的主机端口。</span></span><br><span class="line">runoob@runoob:~$ docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> training/webapp python app.py</span><br><span class="line">33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...           PORTS                     NAMES</span><br><span class="line">33e4523d30aa        training/webapp     <span class="string">&quot;python app.py&quot;</span>   ...   <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">5000</span>-&gt;<span class="number">5000</span>/tcp    berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     <span class="string">&quot;python app.py&quot;</span>   ...   <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">32768</span>-&gt;<span class="number">5000</span>/tcp   grave_hopper</span><br><span class="line"><span class="comment">#另外，我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</span></span><br><span class="line">runoob@runoob:~$ docker run -d -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5001</span>:<span class="number">5000</span> training/webapp python app.py</span><br><span class="line">95c6ceef88ca3e71eaf303c2833fd6701d8d1b2572b5613b5a932dfdfe8a857c</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND           ...     PORTS                                NAMES</span><br><span class="line">95c6ceef88ca        training/webapp     <span class="string">&quot;python app.py&quot;</span>   ...  <span class="number">5000</span>/tcp, <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5001</span>-&gt;<span class="number">5000</span>/tcp   adoring_stonebraker</span><br><span class="line">33e4523d30aa        training/webapp     <span class="string">&quot;python app.py&quot;</span>   ...  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">5000</span>-&gt;<span class="number">5000</span>/tcp               berserk_bartik</span><br><span class="line">fce072cc88ce        training/webapp     <span class="string">&quot;python app.py&quot;</span>   ...    <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">32768</span>-&gt;<span class="number">5000</span>/tcp              grave_hopper</span><br><span class="line"><span class="comment">#这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#docker port 命令可以让我们快捷地查看端口的绑定情况</span></span><br><span class="line">runoob@runoob:~$ docker port adoring_stonebraker <span class="number">5000</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5001</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，默认都是绑定 tcp 端口，如果要绑定 UDP 端口，可以在端口后面加上 <strong>&#x2F;udp</strong></p>
<p>Question: udp?</p>
<p>容器的<strong>链接(Linking</strong>)系统是除了端口映射外的另一种可以与容器中应用进行交换的方式;它会在源和接收容器之间创建一个隧道,接收容器可以看到源容器指定的信息</p>
<p>Docker两种方式为容器公开连接信息: </p>
<ul>
<li>环境变量</li>
<li>更新&#x2F;etc&#x2F;hosts</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先创建一个新的数据库容器,启动db容器的时候并没有使用-p与-P标记，避免了暴露数据库端口到外部网络上</span></span><br><span class="line">$sudo docker run -d --name db tranining/postgres</span><br><span class="line"></span><br><span class="line"><span class="comment">#使db容器与web容器建立互联关系;</span></span><br><span class="line"><span class="comment">#--link name:alias  其中namd是链接的容器的名称,alias是这个链接的别名.</span></span><br><span class="line">$ sudo docker run -d -P --name web --link db:db training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 docker ps 来查看容器的连接</span></span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STAT</span><br><span class="line">US PORTS NAMES</span><br><span class="line"><span class="number">349169744e49</span> training/postgres:latest su postgres -c <span class="string">&#x27;/usr About a minute ago Up About a minute 5432/tcp db, web/db&#x27;</span></span><br><span class="line"><span class="comment">#web/db这表示web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用env命令来查看web容器的环境变量</span></span><br><span class="line">$sudo docker run --rm --name web1 --link db:db training/webapp env</span><br><span class="line"><span class="comment">#起点汇总DB_开头的环境变量是提供web容器连接到db使用,前缀采用大写的链接别名</span></span><br><span class="line">DB_NAME=/web2/db</span><br><span class="line">DB_PORT=tcp://<span class="number">172.17</span><span class="number">.0</span><span class="number">.5</span>:<span class="number">5432</span></span><br><span class="line">DB_PORT_5000_TCP=tcp://<span class="number">172.17</span><span class="number">.0</span><span class="number">.5</span>:<span class="number">5432</span></span><br><span class="line">DB_PORT_5000_TCP_PROTO=tcp</span><br><span class="line">DB_PORT_5000_TCP_PORT=<span class="number">5432</span></span><br><span class="line">DB_PORT_5000_TCP_ADDR=<span class="number">172.17</span><span class="number">.0</span><span class="number">.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#同时Docker还添加host信息到父容器的/etc/hosts文件</span></span><br><span class="line">$sudo docker run -it --rm --link db:db training/webapp /<span class="built_in">bin</span>/bash</span><br><span class="line">cat /etc/hosts </span><br></pre></td></tr></table></figure>

<h4 id="跨主机实现互通"><a href="#跨主机实现互通" class="headerlink" title="跨主机实现互通"></a>跨主机实现互通</h4><p>还可以通过通过添加路由route的方式进行跨主机实现互通，但是通常情况下我们不会如此操作，只在特殊环境中使用测试。</p>
<p>比如：<code>Docker1: 172.18.0.1/24 &lt;--&gt; Gateways &lt;--&gt; 192.168.1.99 </code></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>用户可以链接多个子容器到父容器中比如连接多个web到db容器上;</p>
<p>学习额外的机制比如SDN(软件定义网络)或者NFV(网络功能虚拟化)的相关技术 </p>
<h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>端口映射并不是唯一把 docker 连接到另一个容器的方法。</p>
<p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</p>
<p>docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p>
<p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv15185166?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv15185166?spm_id_from=333.999.0.0</a></p>
<p>Question： bridge 和 overlay</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个新的Docker网络</span></span><br><span class="line">$ docker network create -d bridge my-net</span><br><span class="line"><span class="comment">#-d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 Swarm mode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#连接容器</span></span><br><span class="line"><span class="comment">#运行一个容器并连接到新建的my—net网络</span></span><br><span class="line">$ docker run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line"><span class="comment">#打开新的终端，再运行一个容器并加入到my-net网络</span></span><br><span class="line">$ docker run -it --rm --name busybox2 --network my-net busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以再打开一个终端查看容器信息</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             <span class="string">&quot;sh&quot;</span>                <span class="number">11</span> minutes ago      Up <span class="number">11</span> minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             <span class="string">&quot;sh&quot;</span>                <span class="number">16</span> minutes ago      Up <span class="number">16</span> minutes                           busybox1</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来通过ping来证明busybox1容器和busybox2容器建立了互联关系</span></span><br><span class="line"><span class="comment">#在busybox1容器输入以下命令</span></span><br><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (<span class="number">172.19</span><span class="number">.0</span><span class="number">.3</span>): <span class="number">56</span> data <span class="built_in">bytes</span></span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> <span class="number">172.19</span><span class="number">.0</span><span class="number">.3</span>: seq=<span class="number">0</span> ttl=<span class="number">64</span> time=<span class="number">0.072</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> <span class="number">172.19</span><span class="number">.0</span><span class="number">.3</span>: seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.118</span> ms</span><br><span class="line"><span class="comment">#用ping来测试链接 busybox2 容器，他就会解析成172.19.0.3</span></span><br><span class="line"><span class="comment">#同理在 busybox2 容器执行 ping busybox1，也会成功连接到。</span></span><br><span class="line">/ <span class="comment"># ping busybox1</span></span><br><span class="line">PING busybox1 (<span class="number">172.19</span><span class="number">.0</span><span class="number">.2</span>): <span class="number">56</span> data <span class="built_in">bytes</span></span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> <span class="number">172.19</span><span class="number">.0</span><span class="number">.2</span>: seq=<span class="number">0</span> ttl=<span class="number">64</span> time=<span class="number">0.064</span> ms</span><br><span class="line"><span class="number">64</span> <span class="built_in">bytes</span> <span class="keyword">from</span> <span class="number">172.19</span><span class="number">.0</span><span class="number">.2</span>: seq=<span class="number">1</span> ttl=<span class="number">64</span> time=<span class="number">0.143</span> ms</span><br><span class="line"><span class="comment">#这样，busybox1 容器和 busybox2 容器建立了互联关系</span></span><br></pre></td></tr></table></figure>

<h1 id="Question："><a href="#Question：" class="headerlink" title="Question："></a>Question：</h1><p>Question: swarm集群要不要讲</p>
<p>Question:存储驱动</p>
<p>Question:engine</p>
<p>Question: 容器格式</p>
<hr>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>kerbernets</p>
<p>docker网络</p>
<p>挂载</p>
<hr>
<h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><p>最大区别：</p>
<p>进程&#x2F;程序</p>
<p>​	轻量，简单</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Docker/" rel="tag"># Docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/21/%E6%80%BB%E4%BD%93%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2/" rel="prev" title="总体课程大纲">
      <i class="fa fa-chevron-left"></i> 总体课程大纲
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/21/AWS-Learnlab/" rel="next" title="AWS Learnlab">
      AWS Learnlab <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%A7%E4%BD%ACslides%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">大佬slides的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pdf"><span class="nav-number">1.1.</span> <span class="nav-text">pdf</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%B8%A6%E7%9A%84tutorial%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">2.0.1.</span> <span class="nav-text">自带的tutorial命令行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">3.</span> <span class="nav-text">参考资料</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%A1%A3"><span class="nav-number">3.1.</span> <span class="nav-text">文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E9%A2%91"><span class="nav-number">3.2.</span> <span class="nav-text">视频</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Slides%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">Slides结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDocker"><span class="nav-number">4.1.</span> <span class="nav-text">什么是Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-can-I-use-Docker-for"><span class="nav-number">4.2.</span> <span class="nav-text">What can I use Docker for?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83"><span class="nav-number">4.3.</span> <span class="nav-text">和传统的虚拟化方式比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Docker"><span class="nav-number">4.4.</span> <span class="nav-text">为什么要用Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E7%9A%84%E4%BD%93%E7%B3%BB%EF%BC%88architecture%EF%BC%89"><span class="nav-number">4.5.</span> <span class="nav-text">Docker的体系（architecture）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#daemon"><span class="nav-number">4.5.1.</span> <span class="nav-text">daemon</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84Docker%E7%BB%84%E6%88%90"><span class="nav-number">4.6.</span> <span class="nav-text">完整的Docker组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E5%86%85%E9%83%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.7.</span> <span class="nav-text">Docker内部的具体实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB"><span class="nav-number">4.8.</span> <span class="nav-text">Docker资源隔离</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Namespace%E7%9A%84%E5%85%AD%E9%A1%B9%E9%9A%94%E7%A6%BB"><span class="nav-number">4.8.1.</span> <span class="nav-text">Namespace的六项隔离</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E5%B8%B8%E8%A7%81%E6%A6%82%E5%BF%B5"><span class="nav-number">4.9.</span> <span class="nav-text">Docker常见概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="nav-number">5.</span> <span class="nav-text">指令+重要概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#image-%E9%95%9C%E5%83%8F"><span class="nav-number">5.1.</span> <span class="nav-text">image 镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.1.1.</span> <span class="nav-text">创建镜像的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">5.1.2.</span> <span class="nav-text">镜像操作常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#save%E5%92%8Cexport%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.3.</span> <span class="nav-text">save和export的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-%E5%AE%B9%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">Container 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A0%87%E5%87%86%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.1.</span> <span class="nav-text">创建并运行容器的标准操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">5.2.2.</span> <span class="nav-text">启动容器有两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">5.2.3.</span> <span class="nav-text">容器操作常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-load-%E4%B8%8E-Docker-import-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">5.2.4.</span> <span class="nav-text">Docker load 与 Docker import 的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rm%E5%92%8Crmi%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.5.</span> <span class="nav-text">rm和rmi的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%93%E5%BA%93"><span class="nav-number">5.3.</span> <span class="nav-text">仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Public"><span class="nav-number">5.3.1.</span> <span class="nav-text">Public</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Private"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">Private</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">5.3.2.</span> <span class="nav-text">镜像仓库操作常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="nav-number">5.3.3.</span> <span class="nav-text">创建和使用私有仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#curl%E5%91%BD%E4%BB%A4"><span class="nav-number">5.3.4.</span> <span class="nav-text">curl命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%EF%BC%88Automated-Builds%EF%BC%89"><span class="nav-number">5.3.5.</span> <span class="nav-text">自动创建（Automated Builds）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dockerfile"><span class="nav-number">5.4.</span> <span class="nav-text">Dockerfile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.1.</span> <span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-%E9%95%9C%E5%83%8F%E7%94%9F%E6%88%90%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">5.4.2.</span> <span class="nav-text">docker 镜像生成常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">5.4.3.</span> <span class="nav-text">构建镜像的几种方式:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile%E6%8C%87%E4%BB%A4"><span class="nav-number">5.4.4.</span> <span class="nav-text">Dockerfile指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FROM-%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF"><span class="nav-number">5.4.4.1.</span> <span class="nav-text">FROM - 基础镜像信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LABEL-%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF"><span class="nav-number">5.4.4.2.</span> <span class="nav-text">LABEL - 标签信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAINTAINER-%E7%BB%B4%E6%8A%A4%E8%80%85%E4%BF%A1%E6%81%AF"><span class="nav-number">5.4.4.3.</span> <span class="nav-text">MAINTAINER - 维护者信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RUN-%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-number">5.4.4.4.</span> <span class="nav-text">RUN - 镜像操作命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMD-%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="nav-number">5.4.4.5.</span> <span class="nav-text">CMD- 容器启动时执行指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPOSE-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E6%8C%87%E4%BB%A4"><span class="nav-number">5.4.4.6.</span> <span class="nav-text">EXPOSE - 端口映射指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENV-%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%8C%87%E4%BB%A4"><span class="nav-number">5.4.4.7.</span> <span class="nav-text">ENV - 修改环境变量指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARG-%E6%9E%84%E5%BB%BA%E5%8F%82%E6%95%B0"><span class="nav-number">5.4.4.8.</span> <span class="nav-text">ARG - 构建参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ADD-%E6%B7%BB%E5%8A%A0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%88%B0%E9%95%9C%E5%83%8F%E6%8C%87%E4%BB%A4"><span class="nav-number">5.4.4.9.</span> <span class="nav-text">ADD - 添加指定目录文件到镜像指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COPY-%E5%A4%8D%E5%88%B6%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E7%9B%AE%E5%BD%95%E5%88%B0%E5%AE%B9%E5%99%A8%E4%B8%AD"><span class="nav-number">5.4.4.10.</span> <span class="nav-text">COPY - 复制指定文件或者目录到容器中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENTRYPOINT-%E9%85%8D%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E8%BF%9B%E5%85%A5%E5%90%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4-%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8C%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">5.4.4.11.</span> <span class="nav-text">ENTRYPOINT - 配置容器启动进入后的执行命令-应用运行前的准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VOLUME-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E6%88%96%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E6%8C%82%E8%BD%BD%E7%82%B9-%E5%AE%9A%E4%B9%89%E5%8C%BF%E5%90%8D%E5%8D%B7"><span class="nav-number">5.4.4.12.</span> <span class="nav-text">VOLUME- 创建本地主机或其他主机挂载点-定义匿名卷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#USER-%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%90%8D%E7%94%A8%E6%88%B7%E5%90%8D%E6%88%96%E8%80%85UID"><span class="nav-number">5.4.4.13.</span> <span class="nav-text">USER- 指定容器运行时名用户名或者UID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WORKDIR-%E9%85%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="nav-number">5.4.4.14.</span> <span class="nav-text">WORKDIR - 配置工作目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ONBUILD-%E4%B8%BA%E4%BB%96%E4%BA%BA%E5%81%9A%E5%AB%81%E8%A1%A3%E8%A3%B3"><span class="nav-number">5.4.4.15.</span> <span class="nav-text">ONBUILD - 为他人做嫁衣裳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STOPSIGNAL-%E6%8C%87%E5%AE%9A%E6%89%80%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E5%90%AF%E5%8A%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%8E%A5%E6%94%B6%E9%80%80%E5%87%BA%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%80%BC"><span class="nav-number">5.4.4.16.</span> <span class="nav-text">STOPSIGNAL - 指定所创建镜像启动的容器接收退出的信号值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SHELL-%E6%8C%87%E5%AE%9A%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%B6%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8shell%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.4.17.</span> <span class="nav-text">SHELL - 指定其他命令执行时默认使用shell的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HEALTHCHECK-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="nav-number">5.4.4.18.</span> <span class="nav-text">HEALTHCHECK - 健康检查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.5.</span> <span class="nav-text">Docker容器文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volume-%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="nav-number">5.6.</span> <span class="nav-text">Volume 数据卷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">5.6.1.</span> <span class="nav-text">容器中管理数据的主要两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%85%B1%E4%BA%AB%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">5.6.2.</span> <span class="nav-text">数据管理共享的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">5.6.3.</span> <span class="nav-text">数据卷命令行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">5.6.4.</span> <span class="nav-text">数据卷容器命令行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE"><span class="nav-number">5.6.5.</span> <span class="nav-text">数据卷容器迁移数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Z%E5%92%8Cz%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.6.6.</span> <span class="nav-text">Z和z的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E8%AF%B4%E6%98%8E"><span class="nav-number">5.6.7.</span> <span class="nav-text">总结说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88UnionFS"><span class="nav-number">5.7.</span> <span class="nav-text">联合文件系统（UnionFS)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Compose-%EF%BC%88%E9%9C%80%E8%A6%81%E5%8A%A0%E5%BC%BA%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="nav-number">5.8.</span> <span class="nav-text">Docker Compose （需要加强学习）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker-Compose%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="nav-number">5.8.0.1.</span> <span class="nav-text">Docker Compose重要概念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Machine"><span class="nav-number">5.9.</span> <span class="nav-text">Docker Machine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.10.</span> <span class="nav-text">容器连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%80%9A%E8%BF%87%E7%AB%AF%E5%8F%A3%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%B8%80%E4%B8%AAdocker%E5%AE%B9%E5%99%A8"><span class="nav-number">5.10.1.</span> <span class="nav-text">实现通过端口连接到一个docker容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%A8%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E4%BA%92%E9%80%9A"><span class="nav-number">5.10.1.1.</span> <span class="nav-text">跨主机实现互通</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.10.1.2.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="nav-number">5.11.</span> <span class="nav-text">容器互联</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Question%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">Question：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD"><span class="nav-number">7.</span> <span class="nav-text">后续</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%90%E9%97%AE"><span class="nav-number">8.</span> <span class="nav-text">提问</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chao Cao"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Chao Cao</p>
  <div class="site-description" itemprop="description">为天地立心，为生民立命，为往圣继绝学，为万世开太平</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/HenryVarro666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;HenryVarro666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ccao2679@umd.edu" title="E-Mail → mailto:ccao2679@umd.edu" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chao Cao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">147k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">2:14</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

</body>
</html>
